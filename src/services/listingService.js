const supabase = require('../config/supabase');
const { calculateSustainabilityMetrics } = require('../utils/sustainabilityCalculator');

class ListingService {
  // Helper to map DB model (snake_case) to App model (camelCase)
  _toAppModel(dbListing) {
    if (!dbListing) return null;
    const { 
      seller_id, 
      created_at, 
      updated_at, 
      expires_at, 
      posted_at, 
      living_community,
      event_date,
      cover_image,
      sold_to_user_id,
      sustainability_score,
      eco_impact_data,
      ...rest 
    } = dbListing;

    return {
      ...rest,
      sellerId: seller_id,
      createdAt: created_at,
      updatedAt: updated_at,
      expiresAt: expires_at,
      postedAt: posted_at,
      livingCommunity: living_community,
      eventDate: event_date,
      coverImage: cover_image,
      soldToUserId: sold_to_user_id,
      sustainabilityScore: sustainability_score,
      ecoImpactData: eco_impact_data
    };
  }

  // Helper to map App model to DB model
  _toDbModel(appListing) {
    const { 
      sellerId, 
      createdAt, 
      updatedAt, 
      expiresAt, 
      postedAt, 
      livingCommunity,
      eventDate,
      coverImage,
      soldToUserId,
      sustainabilityScore,
      ecoImpactData,
      ...rest 
    } = appListing;

    const dbListing = { ...rest };
    if (sellerId !== undefined) dbListing.seller_id = sellerId;
    if (createdAt !== undefined) dbListing.created_at = createdAt;
    if (updatedAt !== undefined) dbListing.updated_at = updatedAt;
    if (expiresAt !== undefined) dbListing.expires_at = expiresAt;
    if (postedAt !== undefined) dbListing.posted_at = postedAt;
    if (livingCommunity !== undefined) dbListing.living_community = livingCommunity;
    if (coverImage !== undefined) dbListing.cover_image = coverImage;
    if (soldToUserId !== undefined) dbListing.sold_to_user_id = soldToUserId;
    if (sustainabilityScore !== undefined) dbListing.sustainability_score = sustainabilityScore;
    if (ecoImpactData !== undefined) dbListing.eco_impact_data = ecoImpactData;
    if (eventDate !== undefined) {
        dbListing.event_date = eventDate === '' ? null : eventDate;
    }

    return dbListing;
  }

  /**
   * Create a new listing
   * @param {Object} listingData
   * @returns {Promise<Object>}
   */
  async createListing(listingData) {
    // Calculate sustainability metrics
    const { sustainabilityScore, ecoImpactData } = calculateSustainabilityMetrics(listingData);

    const dbPayload = this._toDbModel({
      ...listingData,
      sustainabilityScore,
      ecoImpactData,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    });

    // Remove id if it's auto-generated by DB (UUID)
    // But if the app generates an ID (like Date.now()), we might want to keep it?
    // Supabase uses UUID. Date.now() is not a UUID.
    // We should let Supabase generate the ID (UUID) and return it.
    // So we remove 'id' from payload if it exists and is not a valid UUID.
    // For migration, if we want to keep old IDs, it might be tricky if they are not UUIDs.
    // The previous implementation used Date.now().toString().
    // Supabase `id` is UUID. We can't put Date.now() into UUID column.
    // So we will let Supabase generate new IDs.
    delete dbPayload.id; 

    const { data, error } = await supabase
      .from('listings')
      .insert(dbPayload)
      .select()
      .single();

    if (error) {
      throw new Error(`Error creating listing: ${error.message}`);
    }

    return this._toAppModel(data);
  }

  /**
   * Get all listings with filters
   * @param {Object} filters
   * @returns {Promise<Array<Object>>}
   */
  async getAllListings(filters = {}) {
    let query = supabase.from('listings').select('*');

    // Filters
    if (filters.sellerId) {
      query = query.eq('seller_id', filters.sellerId);
    }
    if (filters.category) {
      query = query.eq('category', filters.category);
    }
    if (filters.minPrice) {
      query = query.gte('price', filters.minPrice);
    }
    if (filters.maxPrice) {
      query = query.lte('price', filters.maxPrice);
    }
    if (filters.excludeSold) {
        query = query.eq('sold', false);
    }

    if (filters.livingCommunities && filters.livingCommunities.length > 0) {
        query = query.in('living_community', filters.livingCommunities);
    }
    
    // Sort
    if (filters.sortBy) {
        switch (filters.sortBy) {
            case 'price_asc':
                query = query.order('price', { ascending: true });
                break;
            case 'price_desc':
                query = query.order('price', { ascending: false });
                break;
            case 'newest':
            default:
                query = query.order('posted_at', { ascending: false });
                break;
        }
    } else {
        query = query.order('posted_at', { ascending: false });
    }

    // Pagination
    if (filters.page && filters.limit) {
        const from = (filters.page - 1) * filters.limit;
        const to = from + filters.limit - 1;
        query = query.range(from, to);
    }

    const { data, error } = await query;

    if (error) {
      throw new Error(`Error fetching listings: ${error.message}`);
    }

    return data.map(l => this._toAppModel(l));
  }

  /**
   * Get listing by ID
   * @param {string} id
   * @returns {Promise<Object|null>}
   */
  async getListingById(id) {
    const { data, error } = await supabase
      .from('listings')
      .select('*')
      .eq('id', id)
      .single();

    if (error) {
        if (error.code === 'PGRST116') return null;
        throw new Error(`Error fetching listing: ${error.message}`);
    }

    return this._toAppModel(data);
  }

  /**
   * Get multiple listings by IDs
   * @param {Array<string>} ids
   * @returns {Promise<Array<Object>>}
   */
  async getListingsByIds(ids) {
      if (!ids || ids.length === 0) return [];
      
      const { data, error } = await supabase
        .from('listings')
        .select('*')
        .in('id', ids);

      if (error) throw new Error(`Error fetching listings: ${error.message}`);
      
      return data.map(l => this._toAppModel(l));
  }

  /**
   * Update listing
   * @param {string} id
   * @param {Object} updates
   * @returns {Promise<Object>}
   */
  async updateListing(id, updates) {
    // Recalculate metrics if relevant fields are updated
    let metricsUpdates = {};
    if (updates.condition || updates.category || updates.livingCommunity) {
        const currentListing = await this.getListingById(id);
        if (currentListing) {
            const mergedListing = { ...currentListing, ...updates };
            const { sustainabilityScore, ecoImpactData } = calculateSustainabilityMetrics(mergedListing);
            metricsUpdates = { sustainabilityScore, ecoImpactData };
        }
    }

    const appUpdates = {
      ...updates,
      ...metricsUpdates,
      updatedAt: new Date().toISOString()
    };
    const dbUpdates = this._toDbModel(appUpdates);
    
    // Prevent updating id or seller_id via updateListing if not intended
    delete dbUpdates.id;
    delete dbUpdates.seller_id; 

    const { data, error } = await supabase
      .from('listings')
      .update(dbUpdates)
      .eq('id', id)
      .select()
      .single();

    if (error) {
      throw new Error(`Error updating listing: ${error.message}`);
    }

    return this._toAppModel(data);
  }

  /**
   * Delete listing
   * @param {string} id
   * @returns {Promise<boolean>}
   */
  async deleteListing(id) {
    const { error } = await supabase
      .from('listings')
      .delete()
      .eq('id', id);

    if (error) {
      throw new Error(`Error deleting listing: ${error.message}`);
    }

    return true;
  }

  /**
   * Get listings expiring within a specific time range
   * @param {number} startHoursFromNow 
   * @param {number} endHoursFromNow 
   * @returns {Promise<Array<Object>>}
   */
  async getListingsExpiringInWindow(startHoursFromNow, endHoursFromNow) {
    const now = new Date();
    const startTime = new Date(now.getTime() + startHoursFromNow * 60 * 60 * 1000).toISOString();
    const endTime = new Date(now.getTime() + endHoursFromNow * 60 * 60 * 1000).toISOString();

    const { data, error } = await supabase
      .from('listings')
      .select('*')
      .gt('expires_at', startTime)
      .lt('expires_at', endTime)
      .eq('sold', false); // Only active listings

    if (error) {
      throw new Error(`Error fetching expiring listings: ${error.message}`);
    }

    return data.map(l => this._toAppModel(l));
  }

  /**
   * Get expired listings
   * @returns {Promise<Array<Object>>}
   */
  async getExpiredListings() {
      const now = new Date().toISOString();
      const { data, error } = await supabase
        .from('listings')
        .select('*')
        .lt('expires_at', now);
        
      if (error) throw new Error(`Error fetching expired listings: ${error.message}`);
      
      return data.map(l => this._toAppModel(l));
  }
}

module.exports = new ListingService();
